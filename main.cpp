#include <stdio.h>  //标准输入输出
//gitignore 忽略文件  +  实型变量运算
int main() {
    int a = 3 / 2;
    printf("h=%f\n",a);
    printf("h=%f\n",1/3);
    printf("i=%f\n",5/3);
    printf("g=%f\n",1/4);
    /**
     * 除法运算是大坑   要不然全部用成  double 运算  要不然有舍入问题
     * 它会自动转换为IEEE754格式 根据整数的保留位数自动截取长度
     * 总结 ：运算时用 %f  就行  别用%d
     *         把所有数都加 1.0     !!!!
     */
    //1.0/3按照单精度计算只保证小数点后面的前6位是有效位数（精度是6），
    // 所以计算结果是0.333333，0.333333*3=0.999999。不过在机器上运行的结果是1.000000。
    // 书上讲的只是理论计算的结果，在机器上运行有可能不同。
    printf("a=%f\n",1.0/3*3);


    //只要整数部分
    printf("b=%f\n",3/2);
    //表明了它计算的时候这两数进行计算然后 再根据输出展示不同的结果
    printf("i=%f\n",3.0/2);
    //可能内部存的数是浮点类型  然后尾数部分为0.1  然后用整数形式展示就会变成0
    //在C语言中浮点数使用的是IEEE754编码，也就是说一个32位的int类型的数1，使用IEEE754编码所表示的数值是多少的问题。
    //错误用法
    printf("j=%d\n",3.0/2);
    /**
     *  例如 3/2 算出来是1  然后根据输出格式展示
     *  3.0/2  是  1.5 然后根据输出格式展示
     */
    printf("c=%d\n",3/2);

    //
    //运算 只用整形部分  然后1/3算出来 0  *3 =0
    printf("e=%f\n",1/3*3);
    //IEEE754  0    别乱用%d
    printf("f=%d\n",1/3*3);
    printf("g=%f\n",1.0/3);
    printf("h=%f\n",1/3);
    //别乱用%d  会乱截取长度
    printf("k=%d\n",8.0/7);
    /**  输出结果
     * a=1.000000
    b=1.000000
    b=1.000000
     */





    //乱除  它如果是0  输出的还是上一个数
    //它如果是0  输出的还是上一个数
    //也有可能是编译器的问题
    printf("b=%f\n",3/2);
    printf("e=%f\n",1/3*3);
    printf("h=%f\n",1/3);
    printf("i=%f\n",5/3);
    printf("g=%f\n",1/4);

    printf("========================================\n");
    printf("==============正确用法==================\n");
    printf("========================================\n");
    printf("a=%f\n",1.0/3*3);

    //表明了它计算的时候这两数进行计算然后 再根据输出展示不同的结果
    printf("i=%f\n",3.0/2);

    printf("g=%f\n",1.0/3);
    /**
     * 除法运算是大坑   要不然全部用成  double 运算  要不然有舍入问题
     * 它会自动转换为IEEE754格式 根据整数的保留位数自动截取长度
     * 总结 ：运算时用 %f  就行  别用%d
     *         把所有数都加 1.0     !!!!
     */


    return 0;
}
